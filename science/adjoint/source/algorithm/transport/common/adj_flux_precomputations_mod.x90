!-----------------------------------------------------------------------------
! (c) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Adjoint of needed flux_precomputation_type member functions.

module adj_flux_precomputations_mod

  use constants_mod,                only : r_tran, i_def
  use r_tran_field_mod,             only : r_tran_field_type
  use integer_field_mod,            only : integer_field_type
  use mesh_mod,                     only : mesh_type
  use flux_precomputations_alg_mod, only : flux_precomputations_type
  use log_mod,                      only : log_event,                         &
                                           log_scratch_space,                 &
                                           LOG_LEVEL_ERROR
  use split_transport_utils_mod,    only : get_direction_w2_fs,               &
                                           get_num_split_steps
  use extrusion_mod,                only : PRIME_EXTRUSION

  implicit none

  private

  public :: adj_initialise_step

  contains

  !=============================================================================
  !> @brief   Adjoint of flux_precomputations_type initialise_step method.
  !> @param[in,out] field_new           ACTIVE  Reconstructed field at W2 points
  !> @param[in,out] field_old           ACTIVE  Initial W3 field
  !> @param[in]     ls_field_old        PASSIVE Initial W3 field
  !> @param[in]     direction           Splitting direction (h, v, or 3d) to
  !!                                    compute reconstruction
  !> @param[in]     transport_metadata  Contains transport configuration options
  !> @param[in]     final_rk_stage      Whether this is the last Runge-Kutta stage
  subroutine adj_initialise_step( flux_pc, step, ref_flux )

    implicit none

    class(flux_precomputations_type), intent(inout) :: flux_pc
    integer(kind=i_def),              intent(in)    :: step
    type(r_tran_field_type),          intent(in)    :: ref_flux

    ! Local variables
    integer(kind=i_def)                :: splitting
    integer(kind=i_def)                :: num_steps
    integer(kind=i_def)                :: step_of_substep
    integer(kind=i_def)                :: fs_id, correct_fs_id
    integer(kind=i_def)                :: flux_pc_mesh_id
    type(mesh_type),           pointer :: mesh
    type(r_tran_field_type),   pointer :: ref_flux_pc

    ! Checks ------------------------------------------------------------------
    ! Is the reference flux is on a prime extrusion?
    mesh => ref_flux%get_mesh()
    flux_pc_mesh_id = flux_pc%get_mesh_id_from_idx(1)
    if (mesh%get_extrusion_id() /= PRIME_EXTRUSION) then
      write(log_scratch_space, '(A,I8,A)')                                     &
          'adj_initialise_step: the reference flux ' //                        &
          'provided for step ', step, ' is not on a prime extrusion mesh'
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end if

    ! Is the reference flux in the correct space for this split step?
    splitting = flux_pc % get_splitting()
    fs_id = ref_flux%which_function_space()
    step_of_substep = MOD(step - 1, get_num_split_steps(splitting)) + 1
    correct_fs_id = get_direction_w2_fs(splitting, step_of_substep)
    if (fs_id /= correct_fs_id) then
      write(log_scratch_space, '(A,I8,A,I8,A,I8)')                             &
          'adj_initialise_step: the reference flux ' //                        &
          'provided for step ', step, ' is in space with ID ', fs_id,          &
          ' but the corresponding split step should be in the W2 space' //     &
          'with ID: ', correct_fs_id
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end if

    ! Is the step number valid?
    num_steps = flux_pc % get_num_steps()
    if (step > num_steps .or. step < 1) then
      write(log_scratch_space, '(A,I8,A,I8)')                                  &
          'adj_initialise_step: the value of step: ', step,                    &
          'is not valid. Should be between 1 and ', num_steps
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end if

    ! Set reference flux for this object ---------------------------------------
    ref_flux_pc => flux_pc % get_ref_flux( flux_pc_mesh_id, step )
    if (mesh%get_id() /= flux_pc_mesh_id) then
      call log_event(                                                          &
          'adj_initialise_step: restricting fluxes to the appropriate ' //     &
          'mesh is not yet implemented', LOG_LEVEL_ERROR                       &
      )

    else
      ! Flux is already on the mesh for this precomputation object
      call invoke( inc_X_plus_Y( ref_flux, ref_flux_pc ), &
                   setval_c( ref_flux_pc, 0.0_r_tran ) )
    end if

    end subroutine adj_initialise_step

end module adj_flux_precomputations_mod
