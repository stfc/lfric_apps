!-----------------------------------------------------------------------------
! (c) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module containing adjoint code of the advective update A of a variable f by a wind U

module adj_wt_advective_update_alg_mod

  use check_configuration_mod,              only : get_required_stencil_depth
  use constants_mod,                        only : r_tran, i_def, l_def
  use r_tran_field_mod,                     only : r_tran_field_type
  use finite_element_config_mod,            only : element_order_h,            &
                                                   element_order_v
  use fs_continuity_mod,                    only : Wtheta
  use function_space_mod,                   only : function_space_type
  use function_space_collection_mod,        only : function_space_collection
  use mesh_mod,                             only : mesh_type
  use transport_config_mod,                 only : operators,            &
                                                   fv_horizontal_order,  &
                                                   extended_mesh,        &
                                                   oned_reconstruction
  use transport_enumerated_types_mod,       only : direction_3d, &
                                                   horizontal_monotone_koren
  use log_mod,                              only : log_event,         &
                                                   LOG_LEVEL_ERROR
  use transport_metadata_mod,               only : transport_metadata_type
  use adj_poly_adv_update_kernel_mod,       only : adj_poly_adv_update_kernel_type
  use adj_poly1d_reconstruction_kernel_mod, only : adj_poly1d_reconstruction_kernel_type
  use adj_poly2d_reconstruction_kernel_mod, only : adj_poly2d_reconstruction_kernel_type
  use transport_constants_mod,              only : get_hori_wt_mol_coeffs
  use remap_on_extended_mesh_alg_mod,       only : remap_on_extended_mesh

  implicit none

  private

  public :: adj_hori_wt_update_alg

contains

  !=============================================================================
  !> @brief Compute the adjoint of horizontal advective update of a Wtheta field.
  !> @param[in,out] u_grad_f            Horizontal part of u.grad(f)
  !> @param[in]     ls_wind             Linearisation state wind field
  !> @param[in]     wind_dir            Wind field used to determine direction in kernel
  !> @param[in,out] field               Wtheta field to advect
  !> @param[in]     transport_metadata  Contains transport configuration options
  subroutine adj_hori_wt_update_alg( u_grad_f, ls_wind, wind_dir, field, transport_metadata )

    implicit none

    type(r_tran_field_type),       intent(inout) :: u_grad_f
    type(r_tran_field_type),       intent(in)    :: ls_wind
    type(r_tran_field_type),       intent(in)    :: wind_dir
    type(r_tran_field_type),       intent(inout) :: field
    type(transport_metadata_type), intent(in)    :: transport_metadata

    type(r_tran_field_type)          :: h_reconstruction
    type(r_tran_field_type), pointer :: adv_coeffs

    type(mesh_type),           pointer :: mesh
    type(function_space_type), pointer :: multidata_fs

    integer(kind=i_def) :: mesh_id
    integer(kind=i_def) :: stencil_extent
    integer(kind=i_def) :: stencil_size
    integer(kind=i_def) :: ndata_h

    type(r_tran_field_type),      target  :: remap_field, field_big_halo
    type(r_tran_field_type),      pointer :: field_ptr
    type(r_tran_field_type)               :: dummy

    logical(kind=l_def) :: monotone
    integer(kind=i_def) :: remap_depth

    mesh => ls_wind%get_mesh()
    mesh_id = mesh%get_id()
    if (oned_reconstruction) then
      stencil_size = fv_horizontal_order + 1
    else if (mod(fv_horizontal_order, 2) == 0) then
      stencil_size = 1 + 2*fv_horizontal_order + fv_horizontal_order**2
    else
      stencil_size = MAX(1, 4*fv_horizontal_order + fv_horizontal_order**2)
    end if

    ndata_h = 4*stencil_size
    adv_coeffs => get_hori_wt_mol_coeffs(mesh_id)

    ! Copy field to a large halo version
    call field_big_halo%initialise( field%get_function_space(), &
                                    halo_depth = get_required_stencil_depth() )

    ! Compute reconstruction on a Wtheta multidata field
    ! each Wt point contains 4 values assigned to each edge,
    ! in the order (W,S,E,N) which is the same order as a W2 field
    multidata_fs => function_space_collection%get_fs(                          &
        mesh, element_order_h, element_order_v, Wtheta, 4, ndata_first=.false. &
    )
    call h_reconstruction%initialise( multidata_fs )
    call invoke( setval_c( field_big_halo, 0.0_r_tran ),            &
                 setval_c( h_reconstruction, 0.0_r_tran ) )

    monotone = (transport_metadata%get_horizontal_monotone() == horizontal_monotone_koren)
    if ( extended_mesh .and. (monotone .or. oned_reconstruction) ) then
      remap_depth = int(fv_horizontal_order/2)
      call remap_on_extended_mesh(remap_field, field_big_halo,                 &
                                  monotone,                                    &
                                  transport_metadata%get_enforce_min_value(),  &
                                  transport_metadata%get_min_value(),          &
                                  remap_depth)
      field_ptr => remap_field
    else
      field_ptr => field_big_halo
    end if

    call h_reconstruction % copy_field_properties( dummy )
    stencil_extent = 1_i_def
    call invoke( name="poly_update",                                       &
                 adj_poly_adv_update_kernel_type( u_grad_f,                &
                                                  h_reconstruction,        &
                                                  dummy, stencil_extent,   &
                                                  ls_wind, stencil_extent, wind_dir ) )


    stencil_extent = fv_horizontal_order/2_i_def
    if ( transport_metadata%get_horizontal_monotone() == horizontal_monotone_koren ) then
       call log_event( "ADJ Koren not available for cross stencil of size 5", LOG_LEVEL_ERROR )

    else
      if ( oned_reconstruction ) then
        ! Use 1d reconstruction
        call field_ptr % copy_field_properties( dummy )
        call invoke( name="wt_1d_recon",                                     &
                     adj_poly1d_reconstruction_kernel_type(                  &
                                                  h_reconstruction,          &
                                                  field_ptr,                 &
                                                  dummy, stencil_extent,     &
                                                  adv_coeffs,                &
                                                  ndata_h,                   &
                                                  fv_horizontal_order ) )
      else
        ! Use 2d reconstruction
        call field_big_halo % copy_field_properties( dummy )
        call invoke( name="wt_2d_recon",                                     &
                     adj_poly2d_reconstruction_kernel_type(                  &
                                                  h_reconstruction,          &
                                                  field_big_halo,            &
                                                  dummy, stencil_extent,     &
                                                  adv_coeffs,                &
                                                  ndata_h,                   &
                                                  stencil_size) )
      end if

    end if

    call invoke( inc_X_plus_Y( field, field_ptr ) )
    ! and then setval_c( field_ptr, 0.0_r_tran ) but this can be omitted for faster runtime.

  end subroutine adj_hori_wt_update_alg

end module adj_wt_advective_update_alg_mod
