!-----------------------------------------------------------------------------
! (C) Crown copyright 2024 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Routine for setting up the substepping of the transport

module substep_transport_alg_mod

  ! Constants and types
  use check_configuration_mod,           only: check_any_splitting_hvh, &
                                               check_any_splitting_vhv
  use constants_mod,                     only: i_def, l_def, r_def, r_tran
  use field_mod,                         only: field_type
  use fs_continuity_mod,                 only: W2H, W2V, W3
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use log_mod,                           only: log_event,         &
                                               log_scratch_space, &
                                               LOG_LEVEL_INFO,    &
                                               LOG_LEVEL_ERROR
  use mesh_mod,                          only: mesh_type
  use r_tran_field_mod,                  only: r_tran_field_type
  use transport_constants_mod,           only: get_detj_at_w3_r_tran

  ! Algorithms and kernels
  use calc_departure_wind_kernel_mod,    only: calc_departure_wind_kernel_type
  use hori_dep_dist_eulerian_kernel_mod, only: hori_dep_dist_eulerian_kernel_type
  use lipschitz_diag_alg_mod,            only: lipschitz_computation_alg
  use sci_field_minmax_alg_mod,          only: get_field_minmax

  ! Configs
  use departure_points_config_mod,       only: horizontal_limit, &
                                               horizontal_limit_cap
  use transport_config_mod,              only: dep_pt_stencil_extent,  &
                                               substep_transport,      &
                                               substep_transport_off,  &
                                               substep_transport_two,  &
                                               substep_transport_four, &
                                               substep_transport_adaptive

  implicit none

  private

  public  :: substep_transport_alg

contains

  !> @brief Set up the number of substeps when substepping transport
  !> @details This routine determines the number of substeps required
  !!          (based on estimated horizontal Courant or Lipschitz numbers)
  !!          when substepping the transport
  !> @param[in,out] substeps   Number of substeps
  !> @param[in]     wind       The advecting wind
  !> @param[in]     dt         Transport time step
  subroutine substep_transport_alg(substeps, &
                                   wind,     &
                                   dt)

    implicit none

    ! Arguments
    integer(kind=i_def),     intent(inout) :: substeps
    type(r_tran_field_type), intent(in)    :: wind
    real(kind=r_tran),       intent(in)    :: dt

    ! Departure distance and Lipschitz fields
    type(r_tran_field_type) :: dep_distance
    type(r_tran_field_type) :: dep_wind
    type(r_tran_field_type) :: lipschitz_3d
    type(r_tran_field_type) :: lipschitz_2d
    type(r_tran_field_type) :: lipschitz_x
    type(r_tran_field_type) :: lipschitz_y
    type(r_tran_field_type) :: lipschitz_z
    type(r_tran_field_type) :: lipschitz_z2
    type(r_tran_field_type) :: lipschitz_z2x
    type(r_tran_field_type) :: lipschitz_z2y
    type(r_tran_field_type) :: lipschitz_z2xy

    ! Splitting check for computing departure distance

    ! Number of substeps from departure distance and Lipschitz
    integer(kind=i_def) :: steps_courant, steps_lipschitz

    ! Time step constants
    real(kind=r_tran) :: half_dt, dep_dt

    ! Maximum values of departure distances and extent
    real(kind=r_tran) :: dep_min, dep_max, max_dep_distance, max_hori_dep, min_hori_dep
    real(kind=r_tran) :: lip_min, lip_max, lipxyz_max
    real(kind=r_tran) :: lipx_max, lipy_max, lipz_max, lipxy_max, lip2_max, lip3_max
    real(kind=r_tran) :: stencil_extent, extent_ratio

    ! Function space and mesh
    type(function_space_type), pointer :: w2h_fs
    type(function_space_type), pointer :: w2v_fs
    type(function_space_type), pointer :: w3_fs
    type(mesh_type),           pointer :: mesh
    type(r_tran_field_type),   pointer :: detj_at_w3

    ! Select substep_transport option

    select case ( substep_transport )

    case ( substep_transport_adaptive )
      ! Set substepping based on Lipschitz and departure points

      ! Get model time step
      half_dt = 0.5_r_tran * dt

      ! Get the stencil extent from the configuration
      stencil_extent = real(dep_pt_stencil_extent, r_tran)

      ! Get mesh and function spaces
      mesh => wind%get_mesh()
      w3_fs => function_space_collection%get_fs(mesh, 0, 0, W3)
      w2h_fs => function_space_collection%get_fs(mesh, 0, 0, W2H)
      w2v_fs => function_space_collection%get_fs(mesh, 0, 0, W2V)

      ! Initialise fields
      detj_at_w3 => get_detj_at_w3_r_tran(mesh%get_id())
      call dep_distance%initialise( w2h_fs )
      call dep_wind%initialise( vector_space = w2h_fs )
      call lipschitz_3d%initialise( w3_fs )
      call lipschitz_2d%initialise( w3_fs )
      call lipschitz_x%initialise( w3_fs )
      call lipschitz_y%initialise( w3_fs )
      call lipschitz_z%initialise( w3_fs )
      call lipschitz_z2%initialise( w3_fs )
      call lipschitz_z2x%initialise( w3_fs )
      call lipschitz_z2y%initialise( w3_fs )
      call lipschitz_z2xy%initialise( w3_fs )
      call invoke( setval_c(dep_distance, 0.0_r_tran), &
                   setval_c(dep_wind, 0.0_r_tran) )

      ! Set number of sub steps to 1 initially
      steps_courant   = 1_i_def
      steps_lipschitz = 1_i_def

      ! Compute horizontal departure points using Eulerian time-averaged method
      if (check_any_splitting_hvh()) then
        dep_dt = half_dt
      else
        dep_dt = dt
      end if
      call invoke( calc_departure_wind_kernel_type(dep_wind, wind,  &
                                                   detj_at_w3, 1),  &
                   hori_dep_dist_eulerian_kernel_type(dep_distance, &
                                                      dep_wind,     &
                                                      dep_dt) )

      if ( horizontal_limit == horizontal_limit_cap ) then
        ! Cap the horizontal departure points to lie within the stencil extent
        max_hori_dep = stencil_extent
        min_hori_dep = -max_hori_dep
        call invoke( inc_max_aX(min_hori_dep, dep_distance), &
                     inc_min_aX(max_hori_dep, dep_distance) )
      end if

      ! Get the required maximum stencil extent from the departure distance
      call get_field_minmax(dep_distance, dep_min, dep_max)
      max_dep_distance = max( abs(dep_max), abs(dep_min) )

      ! Compute substeps based on the ratio of the max departure distance
      ! and the stencil extent
      extent_ratio = max_dep_distance/stencil_extent
      steps_courant = ceiling(extent_ratio, i_def)

      ! Compute substepping based on the maximum Lipschitz number
      call lipschitz_computation_alg(lipschitz_3d, lipschitz_2d, &
                                     lipschitz_x, lipschitz_y,   &
                                     lipschitz_z, wind, dt)

      if (check_any_splitting_vhv()) then
        ! Calculate VHV Lipschitz numbers
        call invoke( a_times_X(lipschitz_z2, 0.5_r_tran,     &
                               lipschitz_z),                 &
                     X_plus_Y(lipschitz_z2x, lipschitz_z2,   &
                              lipschitz_x),                  &
                     X_plus_Y(lipschitz_z2y, lipschitz_z2,  &
                              lipschitz_y),                  &
                     X_plus_Y(lipschitz_z2xy, lipschitz_z2x, &
                              lipschitz_y) )
        ! Base maximum Lipschitz on VHV values
        call get_field_minmax(lipschitz_z2, lip_min, lipz_max)
        call get_field_minmax(lipschitz_z2x, lip_min, lipx_max)
        call get_field_minmax(lipschitz_z2y, lip_min, lipy_max)
        call get_field_minmax(lipschitz_z2xy, lip_min, lipxy_max)
        lipxyz_max = max(lipz_max, lipx_max, lipy_max, lipxy_max)
      else
        call get_field_minmax(lipschitz_z, lip_min, lipz_max)
        call get_field_minmax(lipschitz_x, lip_min, lipx_max)
        call get_field_minmax(lipschitz_y, lip_min, lipy_max)
        lipxyz_max = max(lipz_max, lipx_max, lipy_max)
      end if

      ! Get maximum Lipschitz numbers
      call get_field_minmax(lipschitz_3d, lip_min, lip3_max)
      call get_field_minmax(lipschitz_2d, lip_min, lip2_max)
      lip_max = max( lipxyz_max, lip3_max, lip2_max )

      ! Compute substeps based on the max Lipschitz number
      steps_lipschitz = max( ceiling(lip_max, i_def), 1_i_def )

      ! Set number of substeps
      substeps = max( steps_courant, steps_lipschitz )

    case ( substep_transport_off )
      ! Set number of substeps to 1
      substeps = 1_i_def

    case ( substep_transport_two )
      ! Set number of substeps to 2 for debugging
      substeps = 2_i_def

    case ( substep_transport_four )
      ! Set number of substeps to 4 for debugging
      substeps = 4_i_def

    case default
      call log_event('Unrecognised substep_transport option', &
                      LOG_LEVEL_ERROR)

    end select

    if (substeps > 1) then
      write( log_scratch_space, '(A,I4)' ) &
      'Transport: number of gungho transport substeps = ', substeps
      call log_event(log_scratch_space, LOG_LEVEL_INFO)
    end if

  end subroutine substep_transport_alg

end module substep_transport_alg_mod
