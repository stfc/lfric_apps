!-----------------------------------------------------------------------------
! (C) Crown copyright 2023 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Contains central routine for transporting rho times a field.
!> @details Contains routine to transport rho times a field pointing to
!!          particular routines based on the specified transport options.

module transport_rho_times_field_alg_mod

  ! Infrastructure
  use constants_mod,                      only: r_def, r_tran, i_def
  use copy_field_alg_mod,                 only: copy_field
  use extrusion_mod,                      only: SHIFTED
  use field_mod,                          only: field_type
  use flux_precomputations_alg_mod,       only: flux_precomputations_type
  use fs_continuity_mod,                  only: W3, Wtheta
  use function_space_mod,                 only: function_space_type
  use function_space_collection_mod,      only: function_space_collection
  use log_mod,                            only: log_event, LOG_LEVEL_ERROR
  use mesh_mod,                           only: mesh_type
  use mesh_collection_mod,                only: mesh_collection
  use r_tran_field_mod,                   only: r_tran_field_type

  ! Transport objects
  use split_transport_utils_mod,          only: get_dry_config,                &
                                                get_num_split_steps
  use transport_config_mod,               only: splitting
  use transport_controller_mod,           only: transport_controller_type
  use transport_counter_mod,              only: transport_counter_type
  use transport_metadata_mod,             only: transport_metadata_type
  use transport_field_mod,                only: transport_field_r_tran

  ! Kernels
  use sci_enforce_lower_bound_kernel_mod, only: enforce_lower_bound_kernel_type
  use sci_inject_sh_w3_to_wt_kernel_mod,  only: inject_sh_w3_to_wt_kernel_type
  use sci_inject_wt_to_sh_w3_kernel_mod,  only: inject_wt_to_sh_w3_kernel_type

  implicit none

  private

  public :: transport_rho_times_field_alg

contains

  !> @brief Central routine for transporting density multiplied by fields.
  !> @details Performs a whole time step, solving the transport equation for
  !!          rho_n times a field and then returning field/rho_np1 where
  !!          rho_n and rho_np1 are start/end of transport step density.
  !!          Only applicable for fields in W3 or Wtheta
  !> @param[in,out] field_np1_rdef  Field to return at end of transport step
  !> @param[in]     field_n_rdef    Field at the start of the transport step
  !> @param[in,out] transport_controller
  !!                                Object with metadata and precomputations
  !!                                for controlling the transport of the field
  !> @param[in,out] transport_metadata Contains the configuration options for
  !!                                   transporting the field
  subroutine transport_rho_times_field_alg(field_np1_rdef, field_n_rdef,       &
                                           transport_controller,               &
                                           transport_metadata)

    implicit none

    ! Arguments
    type(field_type),                intent(inout) :: field_np1_rdef
    type(field_type),                intent(in)    :: field_n_rdef
    type(transport_controller_type), intent(inout) :: transport_controller
    type(transport_metadata_type),   intent(inout) :: transport_metadata

    ! Local conversions to the r_tran precision
    type(r_tran_field_type) :: field_np1_rtran
    type(r_tran_field_type) :: field_n_rtran
    type(r_tran_field_type) :: rho_field_np1
    type(r_tran_field_type) :: rho_field_n

    ! Local density and shifting conversions
    type(r_tran_field_type),         pointer :: rho_d_n
    type(r_tran_field_type),         pointer :: rho_d_np1
    type(r_tran_field_type)                  :: field_n_sh_w3
    type(r_tran_field_type)                  :: field_np1_sh_w3
    type(function_space_type),       pointer :: w3_shifted_fs
    type(function_space_type),       pointer :: w3_fs

    type(mesh_type),                 pointer :: primary_mesh
    type(mesh_type),                 pointer :: shifted_mesh
    type(transport_counter_type),    pointer :: transport_counter
    type(flux_precomputations_type), pointer :: flux_precomputations
    integer(kind=i_def)                      :: num_dry_steps, number_substeps
    integer(kind=i_def)                      :: dry_splitting

    ! Set up some things that are independent of the function space
    primary_mesh => field_n_rdef%get_mesh()
    shifted_mesh => mesh_collection%get_mesh(primary_mesh, SHIFTED)
    transport_counter => transport_controller%get_transport_counter()
    number_substeps = transport_counter%get_num_substeps()
    flux_precomputations => transport_controller%get_flux_precomputations()

    dry_splitting = splitting(get_dry_config())
    num_dry_steps = get_num_split_steps(dry_splitting)*number_substeps

    ! First transfer r_def fields to be r_tran
    call field_np1_rtran%initialise( field_np1_rdef%get_function_space()  )
    call field_n_rtran%initialise( field_n_rdef%get_function_space()  )
    call copy_field( field_n_rdef, field_n_rtran )

    select case (field_n_rdef%which_function_space())
    case (W3)
      ! field is in the same space as density
      w3_fs => function_space_collection%get_fs(primary_mesh, 0, 0, W3)

      ! Create local fields
      call rho_field_n%initialise( w3_fs)
      call rho_field_np1%initialise( w3_fs)

      ! rho_d_n is from first step
      rho_d_n => flux_precomputations%get_ref_field(primary_mesh%get_id(), 1)
      ! rho_d_np1 is from final step (note substepping is performed in
      ! transport_field and so we need rho_d_np1 from the end of final substep)
      rho_d_np1 => flux_precomputations%get_ref_field(                         &
              primary_mesh%get_id(), num_dry_steps+1                           &
      )

      ! multiply field by rho in native space
      call invoke( X_times_Y(rho_field_n, rho_d_n, field_n_rtran) )

      call transport_field_r_tran(                                             &
              rho_field_np1, rho_field_n, transport_controller,                &
              transport_metadata                                               &
      )

      call invoke( X_divideby_Y(field_np1_rtran, rho_field_np1, rho_d_np1) )

    case (Wtheta)
      ! field is in the shifted space
      w3_shifted_fs => function_space_collection%get_fs(shifted_mesh, 0, 0, W3)

      ! Create some shifted fields
      call field_n_sh_w3%initialise( vector_space=w3_shifted_fs)
      call field_np1_sh_w3%initialise( vector_space=w3_shifted_fs)
      call rho_field_n%initialise( vector_space=w3_shifted_fs)
      call rho_field_np1%initialise( vector_space=w3_shifted_fs)

      ! rho_d_n is from first step
      rho_d_n => flux_precomputations%get_ref_field(shifted_mesh%get_id(), 1)
      ! rho_d_np1 is from final step (note substepping is performed in
      ! transport_field and so we need rho_d_np1 from the end of the final substep)
      rho_d_np1 => flux_precomputations%get_ref_field(                         &
              shifted_mesh%get_id(), num_dry_steps+1                           &
      )

      ! multiply field by rho in shifted space
      if ( transport_metadata%get_enforce_min_value() ) then
        ! Do not interpolate
        call invoke( X_times_Y(rho_field_n, field_n_rtran, rho_d_n) )
      else
        ! Interpolate at top and bottom
        call invoke( inject_wt_to_sh_w3_kernel_type(field_n_sh_w3,             &
                                                    field_n_rtran),            &
                     X_times_Y(rho_field_n, field_n_sh_w3, rho_d_n) )
      end if

      call transport_field_r_tran(                                             &
              rho_field_np1, rho_field_n, transport_controller,                &
              transport_metadata                                               &
      )

      call invoke( X_divideby_Y(field_np1_sh_w3, rho_field_np1, rho_d_np1) )

      ! Turn back to Wtheta
      if ( transport_metadata%get_enforce_min_value() ) then
        ! Do not allow extrapolation
        call invoke( setval_X(field_np1_rtran, field_np1_sh_w3) )
      else
        ! Allow extrapolation
        call invoke( inject_sh_w3_to_wt_kernel_type(field_np1_rtran,           &
                                                    field_np1_sh_w3) )
      end if

    case  default
      call log_event(                                                          &
              'Transport rho*field not implememented for this function space', &
              LOG_LEVEL_ERROR                                                  &
      )

    end select

    ! -------------------------------------------------------------------- !
    ! Copy transported fields back to r_def
    ! -------------------------------------------------------------------- !
    call copy_field( field_np1_rtran, field_np1_rdef )

  end subroutine transport_rho_times_field_alg

end module transport_rho_times_field_alg_mod
