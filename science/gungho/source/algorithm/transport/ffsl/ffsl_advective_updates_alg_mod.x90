!-----------------------------------------------------------------------------
! (C) Crown copyright 2024 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module for holding routines used for advective updates in the
!!        ffsl scheme

module ffsl_advective_updates_alg_mod

  use constants_mod,    only: r_tran
  use r_tran_field_mod, only: r_tran_field_type

  implicit none

  private
  public :: swift_outer_update_tracer
  public :: swift_inner_update_tracer
  public :: ffsl_advective_increment

contains

  !----------------------------------------------------------------------------
  !> @brief Compute the outer advective update of a tracer from the SWIFT
  !!        splitting
  !> @param[in,out]  field_np1    Updated tracer field
  !> @param[in]      field_x      Field after x sweep
  !> @param[in]      field_y      Field after y sweep
  !> @param[in]      dry_mass_np1 Dry mass at time level n+1
  !> @param[in]      dry_mass_x   Dry mass after x sweep
  !> @param[in]      dry_mass_y   Dry mass after y sweep
  !> @param[in]      increment_x  Increment to tracer from x sweep
  !> @param[in]      increment_y  Increment to tracer from y sweep
  !> @param[in]      dt           Timestep used in the transport scheme
  !----------------------------------------------------------------------------
  subroutine swift_outer_update_tracer(field_np1, field_x, field_y,       &
                                       dry_mass_np1, dry_mass_x,          &
                                       dry_mass_y, increment_x,           &
                                       increment_y, dt)

    implicit none

    real(kind=r_tran),       intent(in)    :: dt
    type(r_tran_field_type), intent(inout) :: field_np1
    type(r_tran_field_type), intent(in)    :: field_x, field_y
    type(r_tran_field_type), intent(in)    :: dry_mass_np1, dry_mass_x, dry_mass_y
    type(r_tran_field_type), intent(in)    :: increment_x, increment_y

    type(r_tran_field_type) :: f1, f2
    real(kind=r_tran)       :: minus_half_dt, minus_half_dt_copy

    call f1%initialise( field_x%get_function_space() )
    call f2%initialise( field_y%get_function_space() )

    minus_half_dt      = - 0.5_r_tran*dt
    minus_half_dt_copy = minus_half_dt

    ! TODO #416: a small optimisation would combine increment_x and increment_y
    call invoke( aX_plus_bY(field_np1, minus_half_dt, increment_x, &
                            minus_half_dt_copy, increment_y),      &
                 X_times_Y(f1, field_x, dry_mass_x),               &
                 X_times_Y(f2, field_y, dry_mass_y),               &
                 inc_X_plus_bY(field_np1, 0.5_r_tran, f1),         &
                 inc_X_plus_bY(field_np1, 0.5_r_tran, f2),         &
                 inc_X_divideby_Y(field_np1, dry_mass_np1) )

  end subroutine swift_outer_update_tracer

  !----------------------------------------------------------------------------
  !> @brief Compute the inner advective update of a tracer from the SWIFT
  !!        splitting
  !> @param[in,out]  field_np1    Updated tracer field
  !> @param[in]      field_n      Field at start of timestep
  !> @param[in]      dry_mass_np1 Dry mass at time level n+1
  !> @param[in]      dry_mass_n   Dry mass at start of timestep
  !> @param[in]      increment    Increment from the conservative sweep
  !> @param[in]      dt           Timestep used in the transport scheme
  !----------------------------------------------------------------------------
  subroutine swift_inner_update_tracer(field_np1, field_n,                &
                                       dry_mass_np1, dry_mass_n,          &
                                       increment, dt)

    implicit none

    real(kind=r_tran),       intent(in)    :: dt
    type(r_tran_field_type), intent(inout) :: field_np1
    type(r_tran_field_type), intent(in)    :: field_n
    type(r_tran_field_type), intent(in)    :: dry_mass_np1, dry_mass_n
    type(r_tran_field_type), intent(in)    :: increment

    real(kind=r_tran) :: minus_dt

    minus_dt = - dt

    call invoke( X_times_Y(field_np1, field_n, dry_mass_n),     &
                 inc_X_plus_bY(field_np1, minus_dt, increment), &
                 inc_X_divideby_Y(field_np1, dry_mass_np1) )

  end subroutine swift_inner_update_tracer

  !----------------------------------------------------------------------------
  !> @brief Compute the inner advective update of a tracer
  !> @param[in,out]  increment    Advective updata to the tracer field
  !> @param[in]      field        Initial field
  !> @param[in]      dt           Timestep used in the transport scheme
  !> @param[in]      adv_one      Transported unity field
  !----------------------------------------------------------------------------
  subroutine ffsl_advective_increment(increment, field, dt, adv_one)

    implicit none

    type(r_tran_field_type), intent(inout) :: increment
    type(r_tran_field_type), intent(in)    :: field
    real(kind=r_tran),       intent(in)    :: dt
    type(r_tran_field_type), intent(in)    :: adv_one

    real(kind=r_tran) :: one_over_dt

    type(r_tran_field_type) :: inc_part

    one_over_dt = 1.0_r_tran / dt

    call inc_part%initialise( vector_space = field%get_function_space() )

    ! Compute advective increments, through division by unity transport --
    ! Following Putman and Lin, JCP, 2007:
    ! conservative_field = q - dt * F(q)
    ! adv_one   = 1 - dt * F(1)
    ! inc_part  = q - conservative_field / adv_one
    ! increment = inc_part / dt
    call invoke( name="ffsl_advective_increment",                   &
                 a_plus_x( inc_part, -1.0_r_tran, adv_one ),        &
                 inc_X_times_Y( inc_part, field ),                  &
                 inc_X_plus_bY( increment, one_over_dt, inc_part ), &
                 inc_X_divideby_Y( increment, adv_one ) )

  end subroutine ffsl_advective_increment

end module ffsl_advective_updates_alg_mod

