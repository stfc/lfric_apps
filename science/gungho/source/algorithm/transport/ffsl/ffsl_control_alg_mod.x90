!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Routines for managing FFSL transport schemes.

module ffsl_control_alg_mod

  ! Constants and types
  use constants_mod,                    only: i_def, r_tran, l_def
  use extrusion_mod,                    only: SHIFTED
  use r_tran_field_mod,                 only: r_tran_field_type
  use function_space_collection_mod,    only: function_space_collection
  use function_space_mod,               only: function_space_type
  use fs_continuity_mod,                only: W3, Wtheta
  use sci_geometric_constants_mod,      only: get_panel_id
  use log_mod,                          only: log_event,                       &
                                              LOG_LEVEL_ERROR
  use mesh_mod,                         only: mesh_type
  use mesh_collection_mod,              only: mesh_collection

  ! Transport control
  use flux_precomputations_alg_mod,     only: flux_precomputations_type
  use split_transport_utils_mod,        only: get_num_split_steps,             &
                                              get_splitting_direction,         &
                                              get_splitting_fraction
  use transport_controller_mod,         only: transport_controller_type
  use transport_counter_mod,            only: transport_counter_type
  use transport_enumerated_types_mod,   only: direction_v,                     &
                                              direction_h,                     &
                                              direction_3d,                    &
                                              equation_form_advective,         &
                                              equation_form_conservative,      &
                                              equation_form_consistent
  use transport_metadata_mod,           only: transport_metadata_type

  ! Algorithms
  use end_of_transport_step_alg_mod,    only: end_of_advective_step_alg,       &
                                              end_of_conservative_step_alg,    &
                                              end_of_consistent_step_alg
  use ffsl_hori_alg_mod,                only: ffsl_hori_splitting_alg
  use ffsl_vert_alg_mod,                only: ffsl_vert_transport_alg
  use ffsl_3d_alg_mod,                  only: ffsl_3d_splitting_alg

  ! Kernels
  use sci_inject_sh_w3_to_wt_kernel_mod, only: inject_sh_w3_to_wt_kernel_type
  use sci_inject_wt_to_sh_w3_kernel_mod, only: inject_wt_to_sh_w3_kernel_type

  implicit none

  private

  public :: ffsl_control

contains

  !=============================================================================
  !> @brief Controls 3D/vertical/horizontal FFSL transport.
  !> @details Calls a step of the Flux-Form semi-Lagrangian (FFSL) transport,
  !!          for any form of the transport equation.
  !> @param[in,out] field_np1          Field to return at end of transport step
  !> @param[in]     field_n            Field at the start of the transport step
  !> @param[in,out] transport_controller
  !!                                   Object with metadata and precomputations
  !!                                   to control the transport of the field
  subroutine ffsl_control(field_np1, field_n, transport_controller)

    implicit none

    ! Arguments
    type(r_tran_field_type), target, intent(inout) :: field_np1
    type(r_tran_field_type), target, intent(in)    :: field_n
    type(transport_controller_type), intent(inout) :: transport_controller

    ! Internal variables
    real(kind=r_tran)                        :: dt_frac
    real(kind=r_tran)                        :: step_dt
    integer(kind=i_def)                      :: direction
    logical(kind=l_def)                      :: compute_adv_field
    logical(kind=l_def)                      :: enforce_min_value
    integer(kind=i_def)                      :: function_space
    integer(kind=i_def)                      :: vertical_order
    type(function_space_type),       pointer :: w3_shifted_fs
    type(mesh_type),                 pointer :: mesh
    type(mesh_type),                 pointer :: shifted_mesh
    type(transport_counter_type),    pointer :: transport_counter
    type(transport_metadata_type),   pointer :: transport_metadata
    type(flux_precomputations_type), pointer :: flux_precomputations

    ! Use pointers inside of this algorithm for field_n and field_np1
    ! which saves on a field copy
    type(r_tran_field_type),   pointer :: field_n_ptr
    type(r_tran_field_type),   pointer :: field_np1_ptr
    type(r_tran_field_type),   target  :: field_n_w3_shifted
    type(r_tran_field_type),   target  :: field_np1_w3_shifted
    type(r_tran_field_type)            :: mass_flux
    type(r_tran_field_type)            :: increment

    mesh => field_n%get_mesh()
    transport_counter => transport_controller%get_transport_counter()
    transport_metadata => transport_controller%get_transport_metadata()
    flux_precomputations => transport_controller%get_flux_precomputations()

    function_space = field_n%which_function_space()
    enforce_min_value = transport_metadata%get_enforce_min_value()
    direction = get_splitting_direction(                                       &
        transport_metadata%get_splitting(),                                    &
        transport_counter%get_split_step_of_substep_counter()                  &
    )

    ! Get time step
    dt_frac = get_splitting_fraction(                                          &
        transport_metadata%get_splitting(),                                    &
        transport_counter%get_split_step_of_substep_counter()                  &
    )
    step_dt = dt_frac*transport_counter%get_dt_substep()

    ! Determine whether individual routines should return a flux or updated field
    compute_adv_field = (                                                      &
      transport_metadata%get_equation_form() == equation_form_advective        &
      .or. transport_metadata%get_equation_form() == equation_form_consistent  &
      .or. transport_counter%get_split_step_of_substep_counter() /=            &
           get_num_split_steps(transport_metadata%get_splitting())             &
    )

    ! ======================================================================== !
    ! Convert to shifted W3 if required
    ! ======================================================================== !

    if (function_space == Wtheta) then
      ! If the variable is in Wtheta, move into shifted W3
      shifted_mesh => mesh_collection%get_mesh(mesh, SHIFTED)
      w3_shifted_fs => function_space_collection%get_fs(shifted_mesh, 0_i_def, &
                                                        0_i_def, W3)
      call field_n_w3_shifted%initialise( vector_space = w3_shifted_fs )
      call field_np1_w3_shifted%initialise( vector_space = w3_shifted_fs )
      if (enforce_min_value) then
        call invoke( setval_X(field_n_w3_shifted, field_n) )
      else
        ! Interpolate in bottom/top layers
        call invoke( inject_wt_to_sh_w3_kernel_type(field_n_w3_shifted, field_n) )
      end if
      field_n_ptr => field_n_w3_shifted
      field_np1_ptr => field_np1_w3_shifted
    else
      ! Stay on current mesh
      field_n_ptr => field_n
      field_np1_ptr => field_np1
    end if

    ! ======================================================================== !
    ! Call routine based on direction: vertical; horizontal; or 3D.
    ! ======================================================================== !

    select case (direction)
    case (direction_v)
      vertical_order = transport_metadata%get_ffsl_vertical_order()
      call ffsl_vert_transport_alg(                                            &
              mass_flux, increment, field_np1_ptr, field_n_ptr, step_dt,       &
              transport_controller, vertical_order,                            &
              compute_adv_inc=.false., compute_field_np1=compute_adv_field     &
      )

    case (direction_h)
      call ffsl_hori_splitting_alg(                                            &
              mass_flux, field_np1_ptr, field_n_ptr, step_dt,                  &
              transport_controller,                                            &
              compute_field_np1=compute_adv_field                              &
      )

    case (direction_3d)
      call ffsl_3d_splitting_alg(                                              &
              mass_flux, field_np1_ptr, field_n_ptr, step_dt,                  &
              transport_controller                                             &
      )

    case default
      call log_event( "FFSL control: Unrecognized direction", LOG_LEVEL_ERROR )

    end select

    ! ======================================================================== !
    ! Convert field_np1 back to Wtheta, if required
    ! ======================================================================== !

    if (function_space == Wtheta .and. compute_adv_field) then
      ! If Wtheta variable, move field_np1 back to Wtheta
      if (enforce_min_value) then
        ! Can't generate negatives by extrapolation, so just inject
        call invoke( setval_X(field_np1, field_np1_w3_shifted) )
      else
        ! Extrapolation allowed
        call invoke( inject_sh_w3_to_wt_kernel_type(field_np1, field_np1_w3_shifted) )
      end if
    end if

    ! ======================================================================== !
    ! End of transport step generic routines
    ! ======================================================================== !

    select case ( transport_metadata%get_equation_form() )

    case ( equation_form_conservative )

      ! Include dt in the mass flux
      call invoke( inc_a_times_X(step_dt, mass_flux) )

      ! If this is the final step, field_np1 will be computed here from the fluxes
      ! over the whole transport step
      ! If this is not the final step, field_np1 already includes the *advective*
      ! increment, and may be adjusted to enforce min value or in blending zone
      call end_of_conservative_step_alg(                                       &
              field_np1, field_n, mass_flux, flux_precomputations,             &
              transport_counter, transport_metadata                            &
      )

    case ( equation_form_consistent )

      ! Include dt in the mass flux
      call invoke( inc_a_times_X(step_dt, mass_flux) )

      ! If this is the final step, field_np1 will be computed here from the fluxes
      ! over the whole transport step
      ! If this is not the final step, field_np1 already includes the *advective*
      ! increment, and may be adjusted to enforce min value or in blending zone
      call end_of_consistent_step_alg(                                         &
              field_np1, mass_flux, flux_precomputations,                      &
              transport_counter, transport_metadata, compute_field_np1=.false. &
      )

    case ( equation_form_advective )
      ! End of step: if necessary enforce min val and overwrite in blending zone
      call end_of_advective_step_alg(                                          &
              field_np1, field_n, transport_counter, transport_metadata        &
      )

    case default
      call log_event( "FFSL control: Unrecognised equation", LOG_LEVEL_ERROR )

    end select

  end subroutine ffsl_control

end module ffsl_control_alg_mod
