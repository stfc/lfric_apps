!-----------------------------------------------------------------------------
! (c) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module containing handwritten adjoint test for adj_flux_precomputations_mod routines
module adjt_flux_precomputations_alg_mod

  use field_mod,                           only : field_type
  use r_tran_field_mod,                    only : r_tran_field_type
  use mesh_mod,                            only : mesh_type
  use function_space_mod,                  only : function_space_type
  use model_clock_mod,                     only : model_clock_type
  use constants_mod,                       only : i_def, r_def, r_tran
  use log_mod,                             only : log_event,       &
                                                  LOG_LEVEL_ERROR, &
                                                  LOG_LEVEL_INFO,  &
                                                  LOG_LEVEL_DEBUG, &
                                                  log_scratch_space
  use setup_test_alg_mod,                  only : setup_test_tl_transport_controller
  use tl_transport_controller_mod,         only : tl_transport_controller_type
  use transport_controller_mod,            only : transport_controller_type
  use flux_precomputations_alg_mod,        only : flux_precomputations_type
  use init_from_controller_alg_mod,        only : init_flux_fields, &
                                                  init_flux_pc_fieldvals
  use inner_from_controller_rtran_alg_mod, only : flux_pc_prod_rtran, &
                                                  flux_pc_inp_prod_rtran

  implicit none

  private
  public :: adjt_initialise_step_alg

  contains

  !=============================================================================
  !> @brief Adjoint test for adj_initialise_step.
  !> @details Passes if adjoint is transpose of tangent linear.
  !> Determined by testing the equality of inner products
  !> < Mx, Mx > and < AMx, x >, where M is the tangent linear
  !> and A is the adjoint.
  subroutine adjt_initialise_step_alg( mesh, model_clock )

    use adj_flux_precomputations_mod, only : adj_initialise_step

    implicit none

    ! Arguments
    type(mesh_type), pointer, intent(in) :: mesh
    type(model_clock_type),   intent(in) :: model_clock

    ! Arguments for tl and adj calls
    type(flux_precomputations_type),           pointer :: flux_pc
    type(r_tran_field_type), dimension(:), allocatable :: ref_flux
    integer(kind=i_def)                                :: step

    ! Copies of input fields used in inner products
    type(r_tran_field_type), dimension(:), allocatable :: ref_flux_inp
    type(r_tran_field_type), dimension(:), allocatable :: flux_pc_ref_flux_inp

    ! Variables used to handle calculations for fields stored in tl_transport_controller
    type(tl_transport_controller_type)                 :: tl_transport_controller
    type(transport_controller_type),           pointer :: pert_wind_ls_rho_controller
    integer(kind=i_def)                                :: num_steps
    type(field_type)                                   :: dummy
    type(function_space_type),                 pointer :: dummy_vs

    ! Inner products
    real(kind=r_def)  :: ref_flux_inner_prod
    real(kind=r_tran) :: inner1
    real(kind=r_def)  :: ref_flux_ref_flux_inp_inner_prod
    real(kind=r_tran) :: inner2

    ! Test parameters and variables
    real(kind=r_tran), parameter :: overall_tolerance = 1500.0_r_tran
    real(kind=r_tran)            :: machine_tol
    real(kind=r_tran)            :: relative_diff

    call setup_test_tl_transport_controller( mesh, model_clock, tl_transport_controller, dummy, dummy_vs )
    pert_wind_ls_rho_controller => tl_transport_controller % get_pert_wind_ls_rho_controller()
    flux_pc => pert_wind_ls_rho_controller % get_flux_precomputations()
    num_steps = flux_pc % get_num_steps()

    ref_flux_inner_prod = 0.0_r_def

    ! Initialise arguments and call the tangent-linear kernel.
    call init_flux_fields( mesh,                       &
                           num_steps,                  &
                           ref_flux,                   &
                           pert_wind_ls_rho_controller )
    call init_flux_fields( mesh,                       &
                           num_steps,                  &
                           ref_flux_inp,               &
                           pert_wind_ls_rho_controller )
    call init_flux_pc_fieldvals( mesh,                       &
                                 1_i_def,                    &
                                 flux_pc_ref_flux_inp,       &
                                 pert_wind_ls_rho_controller )

    inner1 = 0.0_r_tran
    write(log_scratch_space, *) "adjt_initialise_step inner products:"
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    do step = 1, num_steps
      ref_flux_inner_prod = 0.0_r_def
      call invoke( setval_random( ref_flux(step) ), &
                   setval_X( ref_flux_inp(step), ref_flux(step) ) )
      ! Tangent linear
      call flux_pc % initialise_step( step, ref_flux(step) )
      call invoke( x_innerproduct_x( ref_flux_inner_prod, &
                                     ref_flux(step) ) )
      inner1 = inner1 + real( ref_flux_inner_prod, r_tran )
      write(log_scratch_space, *) "ref_flux(step = ", step, ") inner product = ", ref_flux_inner_prod
      call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    end do
    call flux_pc_prod_rtran( inner1, pert_wind_ls_rho_controller, 1_i_def )

    ref_flux_ref_flux_inp_inner_prod = 0.0_r_def
    inner2 = 0.0_r_tran
    do step = num_steps, 1, -1
      ref_flux_ref_flux_inp_inner_prod = 0.0_r_def
      ! Adjoint
      call adj_initialise_step( flux_pc, step, ref_flux(step) )
      call invoke( x_innerproduct_y( ref_flux_ref_flux_inp_inner_prod, &
                                     ref_flux(step),                   &
                                     ref_flux_inp(step) ) )
      inner2 = inner2 + real( ref_flux_ref_flux_inp_inner_prod, r_tran )
    end do
    call flux_pc_inp_prod_rtran( inner2, pert_wind_ls_rho_controller, 1_i_def, flux_pc_ref_flux_inp )

    call tl_transport_controller % finalise()

    ! Test the inner-product values for equality, allowing for the precision of the active variables
    machine_tol = spacing( max( abs(inner1), abs(inner2) ) )
    relative_diff = abs(inner1 - inner2) / machine_tol
    if (relative_diff < overall_tolerance) then
      write(log_scratch_space, *) "PASSED flux_precomputations%initialise_step:", inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
    else
      write(log_scratch_space, *) "FAILED flux_precomputations%initialise_step:", inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

    if ( allocated(ref_flux) )             deallocate( ref_flux )
    if ( allocated(ref_flux_inp) )         deallocate( ref_flux_inp )
    if ( allocated(flux_pc_ref_flux_inp) ) deallocate( flux_pc_ref_flux_inp )

  end subroutine adjt_initialise_step_alg

end module adjt_flux_precomputations_alg_mod
