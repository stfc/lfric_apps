!-----------------------------------------------------------------------------
! (c) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module containing setup of transport_controller objects for adjoint tests
module setup_test_alg_mod

  use constants_mod,                       only : r_def, i_def, l_def
  use field_mod,                           only : field_type
  use function_space_mod,                  only : function_space_type
  use log_mod,                             only : log_event,         &
                                                  log_scratch_space, &
                                                  LOG_LEVEL_ERROR
  use mesh_mod,                            only : mesh_type
  use model_clock_mod,                     only : model_clock_type
  use finite_element_config_mod,           only : element_order_h, &
                                                  element_order_v
  use fs_continuity_mod,                   only : W2, W3, Wtheta
  use function_space_collection_mod,       only : function_space_collection
  use operator_mod,                        only : operator_type
  use setop_random_kernel_mod,             only : setop_random_kernel_type
  use sci_fem_constants_mod,               only : get_inverse_mass_matrix,     &
                                                  get_inverse_lumped_mass_matrix
  use tl_transport_controller_mod,         only : tl_transport_controller_type
  use transport_metadata_mod,              only : transport_metadata_type
  use transport_metadata_collection_mod,   only : transport_metadata_collection
  use transport_controller_mod,            only : transport_controller_type
  use transport_counter_mod,               only : transport_counter_type

  implicit none

  private :: setup_test_field_n
  public  :: setup_inverse_matrices
  public  :: setup_test_tl_transport_controller

  contains

  !=============================================================================
  !> @brief Sets up field_n with the correct function space and randomised input
  !> @param[in]    mesh                     The model mesh
  !> @param[in]    field_n                  The field_n field to use
  !> @param[in]    vector_space_fnfs_ptr    The vector space for field_n
  !> @param[in]    field_n_name             (Optional) name of field_n, defaults to 'density'
  !>
  subroutine setup_test_field_n( mesh,                  &
                                 transport_metadata,    &
                                 field_n,               &
                                 vector_space_fnfs_ptr, &
                                 field_n_name )

    implicit none

    ! Arguments
    type(mesh_type),                  pointer, intent(in) :: mesh
    type(transport_metadata_type), pointer, intent(inout) :: transport_metadata
    type(field_type),                       intent(inout) :: field_n
    type(function_space_type),     pointer, intent(inout) :: vector_space_fnfs_ptr
    character(len=*),                optional, intent(in) :: field_n_name

    ! Internal variables
    integer(kind=i_def)                                   :: fnfs

    ! Default field_n function space is W3, but for some configurations this can be e.g.: Wtheta
    fnfs = W3
    transport_metadata => transport_metadata_collection%get_transport_metadata('density')
    if ( present( field_n_name ) ) then
      transport_metadata => transport_metadata_collection%get_transport_metadata(field_n_name)
      select case(field_n_name)
        case('density')
          ! Pass since this is already the default behaviour with no field name present
        case('wind')
          fnfs = W3
        case('moisture')
          fnfs = Wtheta
        case('potential_temperature')
          fnfs = Wtheta
        case default
          write(log_scratch_space, *) "Field name ", field_n_name, " for setup_test_tl_transport_controller not recognised."
          call log_event( log_scratch_space, LOG_LEVEL_ERROR )
      end select
    end if

    ! Initialising fields
    vector_space_fnfs_ptr => function_space_collection % get_fs(               &
        mesh, element_order_h, element_order_v, fnfs                           &
    )

    call field_n % initialise( vector_space = vector_space_fnfs_ptr )

    ! Initialise values
    call invoke( setval_random( field_n ) )

  end subroutine setup_test_field_n

  !=============================================================================
  !> @brief   Sets up the inverse mass matrices with randomised inputs
  !> @details Needed because the standard values are too low when used in
  !!          the adjoint, which causes false positives and necessitates enormous
  !!          scaling factors when testing
  !> @param[in]  mesh         The model mesh
  subroutine setup_inverse_matrices( mesh )

    implicit none

    ! Arguments
    type(mesh_type), pointer, intent(in) :: mesh

    ! Internal variables
    type(operator_type),         pointer :: m3_inv
    type(field_type),            pointer :: mt_lumped_inv

    m3_inv => get_inverse_mass_matrix( W3, mesh%get_id() )
    mt_lumped_inv => get_inverse_lumped_mass_matrix( Wtheta, mesh%get_id() )

    call invoke( setop_random_kernel_type( m3_inv ), &
                 setval_random( mt_lumped_inv ) )

  end subroutine setup_inverse_matrices

  !=============================================================================
  !> @brief Sets up the transport_controller and tl_transport_controller object with randomised inputs
  !> @param[in]    mesh                     The model mesh
  !> @param[in]    model_clock              The model clock
  !> @param[inout] tl_transport_controller  The tl_transport_controller object to set
  !> @param[in]    field_n                  The field_n field to use
  !> @param[in]    field_n_name             (Optional) name of field_n, defaults to 'density'
  !>
  subroutine setup_test_tl_transport_controller( mesh,                    &
                                                 model_clock,             &
                                                 tl_transport_controller, &
                                                 field_n,                 &
                                                 vector_space_fnfs_ptr,   &
                                                 field_n_name )

    implicit none

    ! Arguments
    type(mesh_type),              pointer, intent(in) :: mesh
    type(model_clock_type),                intent(in) :: model_clock
    type(tl_transport_controller_type), intent(inout) :: tl_transport_controller
    type(field_type),                   intent(inout) :: field_n
    type(function_space_type), pointer, intent(inout) :: vector_space_fnfs_ptr
    character(len=*),            optional, intent(in) :: field_n_name

    ! Internal variables for setting up tl_transport_controller
    type(function_space_type),                pointer :: vector_space_w2_ptr
    type(function_space_type),                pointer :: vector_space_w3_ptr
    type(field_type)                                  :: ref_field_rdef
    type(field_type)                                  :: ls_ref_field_rdef
    type(field_type)                                  :: wind_n_rdef
    type(field_type)                                  :: ls_wind_n_rdef
    type(field_type)                                  :: wind_np1_rdef
    type(field_type)                                  :: ls_wind_np1_rdef
    integer(kind=i_def)                               :: outer
    type(transport_counter_type),             pointer :: transport_counter
    type(transport_controller_type),          pointer :: transport_controller

    ! Some configs require field_n to be on a different function space to usual ahead of time
    type(transport_metadata_type),   pointer :: transport_metadata

    ! Default field_n function space is W3, but for some configurations this can be e.g.: Wtheta
    if ( present( field_n_name ) ) then
      call setup_test_field_n( mesh, transport_metadata, field_n, vector_space_fnfs_ptr, field_n_name )
    else
      call setup_test_field_n( mesh, transport_metadata, field_n, vector_space_fnfs_ptr )
    end if

    ! Initialising fields
    vector_space_w2_ptr => function_space_collection % get_fs(                 &
        mesh, element_order_h, element_order_v, W2                             &
    )

    vector_space_w3_ptr => function_space_collection % get_fs(                 &
        mesh, element_order_h, element_order_v, W3                             &
    )

    call ref_field_rdef % initialise( vector_space = vector_space_w3_ptr )
    call ls_ref_field_rdef % initialise( vector_space = vector_space_w3_ptr )
    call wind_n_rdef % initialise( vector_space = vector_space_w2_ptr )
    call ls_wind_n_rdef % initialise( vector_space = vector_space_w2_ptr )
    call wind_np1_rdef % initialise( vector_space = vector_space_w2_ptr )
    call ls_wind_np1_rdef % initialise( vector_space = vector_space_w2_ptr )

    ! Initialise values
    call invoke( setval_random( ref_field_rdef ),    &
                 setval_random( ls_ref_field_rdef ), &
                 setval_random( wind_n_rdef ),       &
                 setval_random( ls_wind_n_rdef ),    &
                 setval_random( wind_np1_rdef ),     &
                 setval_random( ls_wind_np1_rdef ) )

    ! Initialise tl_transport_controller object
    outer = 1_i_def
    call tl_transport_controller%initialise( model_clock, ref_field_rdef, ls_ref_field_rdef, &
                                             wind_n_rdef, wind_np1_rdef,                     &
                                             ls_wind_n_rdef, ls_wind_np1_rdef,               &
                                             outer, cheap_update_step=.false. )
    call tl_transport_controller % before_transport_field( transport_metadata )

    transport_controller => tl_transport_controller % get_ls_wind_ls_rho_controller()
    transport_counter => transport_controller % get_transport_counter()
    call transport_counter % set_field_n( field_n )

    transport_controller => tl_transport_controller % get_ls_wind_pert_rho_controller()
    transport_counter => transport_controller % get_transport_counter()
    call transport_counter % set_field_n( field_n )

    transport_controller => tl_transport_controller % get_pert_wind_ls_rho_controller()
    transport_counter => transport_controller % get_transport_counter()
    call transport_counter % set_field_n( field_n )

  end subroutine setup_test_tl_transport_controller

end module setup_test_alg_mod
