!-----------------------------------------------------------------------------
! (c) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Module to get inner product of fields from transport controller at r_def precision

module inner_from_controller_rdef_alg_mod

  use constants_mod,                       only : i_def, l_def, r_def
  use field_mod,                           only : field_type
  use r_tran_field_mod,                    only : r_tran_field_type
  use transport_controller_mod,            only : transport_controller_type
  use flux_precomputations_alg_mod,        only : flux_precomputations_type
  use wind_precomputations_alg_mod,        only : wind_precomputations_type
  use transport_counter_mod,               only : transport_counter_type
  use log_mod,                             only : log_event,       &
                                                  LOG_LEVEL_DEBUG, &
                                                  log_scratch_space

  implicit none

  private

  public :: flux_pc_prod_rdef
  public :: flux_pc_inp_prod_rdef
  public :: flux_counter_prod_rdef
  public :: flux_counter_inp_prod_rdef
  public :: field_n_counter_prod_rdef
  public :: field_n_counter_inp_prod_rdef
  public :: wind_pc_prod_rdef
  public :: wind_pc_inp_prod_rdef

  contains

  !=============================================================================
  !> @brief Increments the rdef inner product by flux_pc_fields.flux_pc_fields
  !> @param[in,out]  inner                 Inner product (rdef) to increment
  !> @param[in,out]  transport_controller  Transport controller object containing the flux precomputations
  !> @param[in]      mesh_idx              The mesh index of the desired fields
  !> @param[in]      flux_sf               (Optional) scale factor for the increment
  subroutine flux_pc_prod_rdef( inner,                &
                                transport_controller, &
                                mesh_idx,             &
                                flux_sf )
    implicit none

    ! Arguments
    real(kind=r_def),                intent(inout) :: inner
    type(transport_controller_type), intent(inout) :: transport_controller
    integer(kind=i_def),                intent(in) :: mesh_idx
    real(kind=r_def),         optional, intent(in) :: flux_sf

    ! Internal variables
    type(flux_precomputations_type),       pointer :: flux_pc
    type(r_tran_field_type),               pointer :: ref_flux_ptr
    integer(kind=i_def)                            :: step
    integer(kind=i_def)                            :: num_steps
    integer(kind=i_def)                            :: mesh_id_from_idx
    real(kind=r_def)                               :: flux_inner_prod

    flux_pc => transport_controller % get_flux_precomputations()
    mesh_id_from_idx = flux_pc % get_mesh_id_from_idx( mesh_idx )
    num_steps = flux_pc % get_num_steps()
    do step = 1, num_steps
      ! We skip the initialisation error checking because we
      ! have explicit behaviour for the input generation based on
      ! whether or not it is initialised.
      ref_flux_ptr => flux_pc % get_ref_flux( mesh_id_from_idx, &
                                              step,             &
                                              skip_check_init = .true._l_def )

      flux_inner_prod = 0.0_r_def
      if ( ref_flux_ptr % is_initialised() ) then
        call invoke( x_innerproduct_x( flux_inner_prod, ref_flux_ptr ) )

        if( present(flux_sf) ) then
          inner = inner + flux_inner_prod*flux_sf
          call invoke( inc_a_times_X(flux_sf, ref_flux_ptr) )
          write(log_scratch_space, *) "Flux precomputations ref_flux(step = ", step, ") inner prod = ", &
                                      flux_inner_prod*flux_sf
        else
          inner = inner + flux_inner_prod
          write(log_scratch_space, *) "Flux precomputations ref_flux(step = ", step, ") inner prod = ", &
                                      flux_inner_prod
        end if
        call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
      end if

    end do

  end subroutine flux_pc_prod_rdef

  !=============================================================================
  !> @brief Increments the rdef inner product by flux_pc_fields.flux_pc_fields_inp
  !> @param[in,out]  inner                 Inner product (rdef) to increment
  !> @param[in,out]  transport_controller  Transport controller object containing the flux precomputations
  !> @param[in]      mesh_idx              The mesh index of the desired fields
  !> @param[in]      flux_pc_inp           Flux precomputations input fields at start of adjoint test
  subroutine flux_pc_inp_prod_rdef( inner,                &
                                    transport_controller, &
                                    mesh_idx,             &
                                    flux_pc_inp )
    implicit none

    ! Arguments
    real(kind=r_def),                   intent(inout) :: inner
    type(transport_controller_type),    intent(inout) :: transport_controller
    integer(kind=i_def),                   intent(in) :: mesh_idx
    type(r_tran_field_type), dimension(:), intent(in) :: flux_pc_inp

    ! Internal variables
    type(flux_precomputations_type),          pointer :: flux_pc
    type(r_tran_field_type),                  pointer :: ref_flux_ptr
    integer(kind=i_def)                               :: step
    integer(kind=i_def)                               :: num_steps
    integer(kind=i_def)                               :: mesh_id_from_idx
    real(kind=r_def)                                  :: flux_inner_prod

    flux_pc => transport_controller % get_flux_precomputations()
    mesh_id_from_idx = flux_pc % get_mesh_id_from_idx( mesh_idx )
    num_steps = flux_pc % get_num_steps()
    do step = 1, num_steps
      ! We skip the initialisation error checking because we
      ! have explicit behaviour for the input generation based on
      ! whether or not it is initialised.
      ref_flux_ptr => flux_pc % get_ref_flux( mesh_id_from_idx, &
                                              step,             &
                                              skip_check_init = .true._l_def )

      flux_inner_prod = 0.0_r_def
      if ( ref_flux_ptr % is_initialised() ) then
        call invoke( x_innerproduct_y( flux_inner_prod, &
                                       ref_flux_ptr,    &
                                       flux_pc_inp(step) ) )
        inner = inner + flux_inner_prod
      end if

    end do

  end subroutine flux_pc_inp_prod_rdef

  !=============================================================================
  !> @brief Increments the rdef inner product by transport_counter_flux_fields.transport_counter_flux_fields
  !> @param[in,out]  inner                 Inner product (rdef) to increment
  !> @param[in,out]  transport_controller  Transport controller object containing the transport counter
  !> @param[in]      flux_sf               (Optional) scale factor for the increment
  subroutine flux_counter_prod_rdef( inner,                &
                                     transport_controller, &
                                     flux_sf )
    implicit none

    ! Arguments
    real(kind=r_def),                intent(inout) :: inner
    type(transport_controller_type), intent(inout) :: transport_controller
    real(kind=r_def),         optional, intent(in) :: flux_sf

    ! Internal variables
    type(transport_counter_type),          pointer :: transport_counter
    type(r_tran_field_type),               pointer :: flux_ptr
    integer(kind=i_def)                            :: step
    integer(kind=i_def)                            :: num_steps
    real(kind=r_def)                               :: flux_inner_prod

    transport_counter => transport_controller % get_transport_counter()
    num_steps = transport_counter % get_num_split_steps_per_substep() - 1
    do step = 1, num_steps
      flux_ptr => transport_counter % get_flux( step )

      flux_inner_prod = 0.0_r_def
      if ( flux_ptr % is_initialised() ) then
        call invoke( x_innerproduct_x( flux_inner_prod, flux_ptr ) )

        if( present(flux_sf) ) then
          inner = inner + flux_inner_prod*flux_sf
          call invoke( inc_a_times_X(flux_sf, flux_ptr) )
          write(log_scratch_space, *) "Transport counter flux(step = ", step, ") inner prod = ", &
                                      flux_inner_prod*flux_sf
        else
          inner = inner + flux_inner_prod
          write(log_scratch_space, *) "Transport counter flux(step = ", step, ") inner prod = ", &
                                      flux_inner_prod
        end if
        call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
      end if

    end do

  end subroutine flux_counter_prod_rdef

  !=============================================================================
  !> @brief Increments the rdef inner product by transport_counter_flux_fields.transport_counter_flux_fields_inp
  !> @param[in,out]  inner                 Inner product (rdef) to increment
  !> @param[in,out]  transport_controller  Transport controller object containing the transport counter
  !> @param[in]      flux_counter_inp      Transport counter input fields at start of adjoint test
  subroutine flux_counter_inp_prod_rdef( inner,                &
                                         transport_controller, &
                                         flux_counter_inp )
    implicit none

    ! Arguments
    real(kind=r_def),                   intent(inout) :: inner
    type(transport_controller_type),    intent(inout) :: transport_controller
    type(r_tran_field_type), dimension(:), intent(in) :: flux_counter_inp

    ! Internal variables
    type(transport_counter_type),             pointer :: transport_counter
    type(r_tran_field_type),                  pointer :: flux_ptr
    integer(kind=i_def)                               :: step
    integer(kind=i_def)                               :: num_steps
    real(kind=r_def)                                  :: flux_inner_prod

    transport_counter => transport_controller % get_transport_counter()
    num_steps = transport_counter % get_num_split_steps_per_substep() - 1
    do step = 1, num_steps
      flux_ptr => transport_counter % get_flux( step )

      flux_inner_prod = 0.0_r_def
      if ( flux_ptr % is_initialised() ) then
        call invoke( x_innerproduct_y( flux_inner_prod, &
                                       flux_ptr,        &
                                       flux_counter_inp(step) ) )
        inner = inner + flux_inner_prod
      end if

    end do

  end subroutine flux_counter_inp_prod_rdef

  !=============================================================================
  !> @brief Increments the rdef inner product by transport_counter_field_n.transport_counter_field_n
  !> @param[in,out]  inner                 Inner product (rdef) to increment
  !> @param[in,out]  transport_controller  Transport controller object containing the transport counter
  !> @param[in]      field_n_sf            (Optional) scale factor for the increment
  subroutine field_n_counter_prod_rdef( inner,                &
                                        transport_controller, &
                                        field_n_sf )
    implicit none

    ! Arguments
    real(kind=r_def),                intent(inout) :: inner
    type(transport_controller_type), intent(inout) :: transport_controller
    real(kind=r_def),         optional, intent(in) :: field_n_sf

    ! Internal variables
    type(transport_counter_type),          pointer :: transport_counter
    type(r_tran_field_type),               pointer :: field_n_ptr
    real(kind=r_def)                               :: field_n_inner_prod

    transport_counter => transport_controller % get_transport_counter()
    field_n_ptr => transport_counter % get_field_n()

    if ( field_n_ptr % is_initialised() ) then
      field_n_inner_prod = 0.0_r_def
      call invoke( x_innerproduct_x( field_n_inner_prod, field_n_ptr ) )

      if( present(field_n_sf) ) then
        inner = inner + field_n_inner_prod*field_n_sf
        call invoke( inc_a_times_X(field_n_sf, field_n_ptr) )
        write(log_scratch_space, *) "Transport counter field_n inner prod = ", &
                                    field_n_inner_prod*field_n_sf
      else
        inner = inner + field_n_inner_prod
        write(log_scratch_space, *) "Transport counter field_n inner prod = ", &
                                    field_n_inner_prod
      end if
      call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    end if

  end subroutine field_n_counter_prod_rdef

  !=============================================================================
  !> @brief Increments the rdef inner product by transport_counter_field_n.transport_counter_field_n_inp
  !> @param[in,out]  inner                 Inner product (rdef) to increment
  !> @param[in,out]  transport_controller  Transport controller object containing the transport counter
  !> @param[in]      field_n_counter_inp   Transport counter input fields at start of adjoint test
  subroutine field_n_counter_inp_prod_rdef( inner,                &
                                            transport_controller, &
                                            field_n_counter_inp )
    implicit none

    ! Arguments
    real(kind=r_def),                intent(inout) :: inner
    type(transport_controller_type), intent(inout) :: transport_controller
    type(r_tran_field_type),            intent(in) :: field_n_counter_inp

    ! Internal variables
    type(transport_counter_type),          pointer :: transport_counter
    type(r_tran_field_type),               pointer :: field_n_ptr
    real(kind=r_def)                               :: field_n_inner_prod

    transport_counter => transport_controller % get_transport_counter()
    field_n_ptr => transport_counter % get_field_n()

    if ( field_n_ptr % is_initialised() ) then
      field_n_inner_prod = 0.0_r_def
      call invoke( x_innerproduct_y( field_n_inner_prod, &
                                     field_n_ptr,        &
                                     field_n_counter_inp ) )
      inner = inner + field_n_inner_prod
    end if

  end subroutine field_n_counter_inp_prod_rdef

  !=============================================================================
  !> @brief Increments the rdef inner product by wind_pc.wind_pc
  !> @param[in,out]  inner                 Inner product (rdef) to increment
  !> @param[in,out]  transport_controller  Transport controller object containing the wind precomputations
  !> @param[in]      mesh_id               Mesh id of the wind field
  !> @param[in]      direction             Direction of wind to add
  !> @param[in]      wind_sf               (Optional) scale factor for the increment
  subroutine wind_pc_prod_rdef( inner,                &
                                transport_controller, &
                                mesh_id,              &
                                direction,            &
                                wind_sf )
    implicit none

    ! Arguments
    real(kind=r_def),                intent(inout) :: inner
    type(transport_controller_type), intent(inout) :: transport_controller
    integer(kind=i_def),                intent(in) :: mesh_id
    integer(kind=i_def),                intent(in) :: direction
    real(kind=r_def),         optional, intent(in) :: wind_sf

    ! Internal variables
    type(wind_precomputations_type),       pointer :: wind_pc
    type(r_tran_field_type),               pointer :: wind_ptr
    real(kind=r_def)                               :: wind_inner_prod

    wind_pc => transport_controller % get_wind_precomputations()
    wind_ptr => wind_pc % get_wind( mesh_id, direction )

    if ( wind_ptr % is_initialised() ) then
      wind_inner_prod = 0.0_r_def
      call invoke( x_innerproduct_x( wind_inner_prod, wind_ptr ) )

      if( present(wind_sf) ) then
        inner = inner + wind_inner_prod*wind_sf
        call invoke( inc_a_times_X(wind_sf, wind_ptr) )
        write(log_scratch_space, *) "Wind precomputations(direction = ", direction, " inner prod = ", &
                                    wind_inner_prod*wind_sf
      else
        inner = inner + wind_inner_prod
        write(log_scratch_space, *) "Wind precomputations(direction = ", direction, " inner prod = ", &
                                    wind_inner_prod
      end if
      call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    end if

  end subroutine wind_pc_prod_rdef

  !=============================================================================
  !> @brief Increments the rdef inner product by wind_pc.wind_pc_inp
  !> @param[in,out]  inner                 Inner product (rdef) to increment
  !> @param[in,out]  transport_controller  Transport controller object containing the wind precomputations
  !> @param[in]      mesh_id               Mesh id of the wind field
  !> @param[in]      direction             Direction of wind to add
  !> @param[in]      wind_pc_inp           Wind precomputation input fields at start of adjoint test
  subroutine wind_pc_inp_prod_rdef( inner,                &
                                    transport_controller, &
                                    mesh_id,              &
                                    direction,            &
                                    wind_pc_inp )
    implicit none

    ! Arguments
    real(kind=r_def),                intent(inout) :: inner
    type(transport_controller_type), intent(inout) :: transport_controller
    integer(kind=i_def),                intent(in) :: mesh_id
    integer(kind=i_def),                intent(in) :: direction
    type(r_tran_field_type),            intent(in) :: wind_pc_inp

    ! Internal variables
    type(wind_precomputations_type),       pointer :: wind_pc
    type(r_tran_field_type),               pointer :: wind_ptr
    real(kind=r_def)                               :: wind_inner_prod

    wind_pc => transport_controller % get_wind_precomputations()
    wind_ptr => wind_pc % get_wind( mesh_id, direction )

    if ( wind_ptr % is_initialised() ) then
      wind_inner_prod = 0.0_r_def
      call invoke( x_innerproduct_y( wind_inner_prod, &
                                     wind_ptr,        &
                                     wind_pc_inp ) )
      inner = inner + wind_inner_prod
    end if

  end subroutine wind_pc_inp_prod_rdef

end module inner_from_controller_rdef_alg_mod
