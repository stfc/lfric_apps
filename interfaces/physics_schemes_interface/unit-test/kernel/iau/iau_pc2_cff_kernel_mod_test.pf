!-----------------------------------------------------------------------------
! Copyright (c) 2023,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
!> Test the physical consistency of cloud fractions in IAU applications
!>
module iau_pc2_cff_kernel_mod_test

  use constants_mod, only: i_def, r_def
  use funit

  implicit none

  private

  public :: iau_pc2_cff_test_type, test_all

  @TestCase
  type, extends(TestCase) :: iau_pc2_cff_test_type

    private

    ! Fields and dof_map
    real(r_def),    allocatable :: qcf(:)
    real(r_def),    allocatable :: del_qcf(:)
    real(r_def),    allocatable :: bcf(:)
    real(r_def),    allocatable :: cff(:)
    real(r_def),    allocatable :: cfl(:)
    integer(i_def), allocatable :: map_wtheta(:)

    ! Inputs that affect code coverage
    real(r_def),    allocatable :: qcf_inp(:)
    real(r_def),    allocatable :: del_qcf_inp(:)
    real(r_def),    allocatable :: cff_inp(:)

    ! KGOs
    real(r_def),    allocatable :: bcf_out(:)
    real(r_def),    allocatable :: cff_out(:)

  contains

    procedure setUp
    procedure tearDown
    procedure test_all

  end type iau_pc2_cff_test_type

  integer(i_def), parameter :: nlayers = 5
  integer(i_def), parameter :: ndf_wtheta = 2
  ! Implicit extra layer is implied in iau_pc2_cff_kernel_mod.F90
  integer(i_def), parameter :: undf_wtheta = ( nlayers + 1_i_def ) * ndf_wtheta

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(iau_pc2_cff_test_type), intent(inout) :: this

    allocate( this%qcf( undf_wtheta ) )
    allocate( this%del_qcf( undf_wtheta ) )
    allocate( this%bcf( undf_wtheta ) )
    allocate( this%cff( undf_wtheta ) )
    allocate( this%cfl( undf_wtheta ) )
    allocate( this%map_wtheta( ndf_wtheta ) )

    ! Each layer features a batch of these field inputs
    ! such that each branch of the kernel logic is visited
    allocate( this%qcf_inp( nlayers + 1 ) )
    allocate( this%del_qcf_inp( nlayers + 1 ) )
    allocate( this%cff_inp( nlayers + 1 ) )

    ! Each layer corresponds to a kgo
    allocate( this%bcf_out( nlayers + 1 ) )
    allocate( this%cff_out( nlayers + 1 ) )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )
    implicit none

    class(iau_pc2_cff_test_type), intent(inout) :: this

    deallocate( this%qcf )
    deallocate( this%del_qcf )
    deallocate( this%bcf )
    deallocate( this%cff )
    deallocate( this%cfl )
    deallocate( this%map_wtheta )

    deallocate( this%qcf_inp )
    deallocate( this%del_qcf_inp )
    deallocate( this%cff_inp )

    deallocate( this%bcf_out )
    deallocate( this%cff_out )

  end subroutine tearDown
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  @Test
  subroutine test_all( this )

    use, intrinsic :: iso_fortran_env, only : real64
    use iau_pc2_cff_kernel_mod,        only : iau_pc2_cff_code

    implicit none

    class(iau_pc2_cff_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-9_r_def   ! r_def 64bit
    real(r_def)            :: answer, use_tol
    integer(i_def)         :: k, df

    this%map_wtheta = (/ 1_i_def, 1_i_def + nlayers + 1_i_def /)

    this%qcf_inp = (/ 0.5_r_def, 0.5_r_def, 0.5_r_def, 1.0_r_def, 1.0_r_def, 0.0_r_def /)
    this%del_qcf_inp = (/ 0.0_r_def, 0.5_r_def, -0.5_r_def, -1.0_r_def, 1.0_r_def, -1.0_r_def /)
    this%cff_inp = (/ 0.5_r_def, 0.5_r_def, 0.5_r_def, 0.0_r_def, 1.0_r_def, 0.0_r_def /)

    this%bcf_out = (/ 0.5_r_def, 1.0_r_def, 0.5_r_def, 0.5_r_def, 0.5_r_def, 0.5_r_def /)
    this%cff_out = (/ 0.5_r_def, 1.0_r_def, 0.0_r_def, 0.0_r_def, 1.0_r_def, 0.0_r_def /)

    ! Create the data
    do k = 0, nlayers
      do df = 1, ndf_wtheta
        this%qcf( this%map_wtheta(df) + k ) = this%qcf_inp( k + 1 )
        this%del_qcf( this%map_wtheta(df) + k ) = this%del_qcf_inp( k + 1 )
        this%cff( this%map_wtheta(df) + k ) = this%cff_inp( k + 1 )
      end do
    end do
    this%bcf = 0.5_r_def
    this%cfl = 0.5_r_def

    ! Test kernel
    call iau_pc2_cff_code( nlayers,                         &
                           this%qcf,                        &
                           this%del_qcf,                    &
                           this%bcf,                        &
                           this%cfl,                        &
                           this%cff,                        &
                           ndf_wtheta,                      &
                           undf_wtheta,                     &
                           this%map_wtheta                  &
                          )

    ! kgo checks for modifiable bcf, cff
    do k = 0, nlayers
      ! Bulk cloud fraction check
      answer = this%bcf_out( k + 1 )
      if ( r_def == real64 ) then
        use_tol = tol
      else
        use_tol = 10.0_r_def * spacing( answer )
      end if
      @assertEqual( answer, this%bcf( this%map_wtheta(1) + k ), use_tol )

      ! Frozen cloud fraction check
      answer = this%cff_out( k + 1 )
      if ( r_def == real64 ) then
        use_tol = tol
      else
        use_tol = 10.0_r_def * spacing( answer )
      end if
      @assertEqual( answer, this%cff( this%map_wtheta(1) + k ), use_tol )
    end do

  end subroutine test_all

end module iau_pc2_cff_kernel_mod_test
